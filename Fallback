private Column buildArrayStructEnrichmentColumn(Dataset<Row> dataset, FieldMappingConf mappingConf) {
    final List<StructArrayField> structFields = mappingConf.getStructArrayFields();
    final String primaryFieldName = mappingConf.getPrimaryFieldName();

    // Create fallback struct for leg1
    final Column fallbackLeg1 = functions.struct(
        functions.lit("leg1").alias("legId"),
        dataset.col(structFields.get(0).getMasterContractId()).alias("masterContractId"),
        dataset.col(structFields.get(0).getWeight()).alias("weight")
    );

    // Create fallback struct for leg2
    final Column fallbackLeg2 = functions.struct(
        functions.lit("leg2").alias("legId"),
        dataset.col(structFields.get(1).getMasterContractId()).alias("masterContractId"),
        dataset.col(structFields.get(1).getWeight()).alias("weight")
    );

    // Primary struct array column
    final Column primaryArray = dataset.col(primaryFieldName);

    // Convert primary array to a map keyed by legId
    Column primaryMap = functions.map_from_entries(
        functions.transform(primaryArray, struct -> functions.struct(struct.getField("legId"), struct))
    );

    // Build fallback map
    Column fallbackMap = functions.map_from_entries(
        functions.array(
            functions.struct(fallbackLeg1.getField("legId"), fallbackLeg1),
            functions.struct(fallbackLeg2.getField("legId"), fallbackLeg2)
        )
    );

    // Merge maps: primaryMap overrides fallbackMap
    Column mergedMap = functions.map_concat(fallbackMap, primaryMap);

    // Final updated array
    Column enrichedArray = functions.map_values(mergedMap);

    // Apply enrichment only if primary is null or empty
    return when(isNullOrEmpty(primaryArray), enrichedArray).otherwise(primaryArray);
}
